# algorithmLearning

关于算法的学习、笔记、代码练习

#### 对数器

##### 思路：

 有一个你待测的方法a，以及一个不计时间成本和空间成本但稳定的方法b

对同一数组（不是同一个地址的数组，是指数组长度、内容值相同的）分别使用两个方法运行

得到的两个结果进行一一比对，可以验证待测方法的运行结果是否正确

##### 优点：

不用依赖平台OG来验证自己写的方法是否正确

比对次数可以自己定义

每次比对的数组长度、数组内容可以自己定义范围

待发现错误时，可以通过缩小数组长度、数值范围等控制变量来进行debug修正

#### master公式的使用

master公式是对递归方法的算法复杂度进行分析

##### 定义

其公式表示为

$$
T(N)=a*T(N/b)+O(N^d)
$$

其中，当且仅当递归时的子部分划分为完全相等的部分时才可以该套用公式

a表示递归调用次数，b表示子部分占比取反，O(N^d)表示除递归操作外，其它操作占用时间复杂度

##### 例如

将一个数组取左右两半进行递归，找出数组最大值

那么在这个例子中，a表示需要将左右两个子部分都进行递归，所以次数为2

每部分占比为1/2，取反为2，所以b为2

除递归方法外，找出数组最大值需要进行一个比较操作，时间复杂度为O(1)

所以套入公式可得

$$
T(N)=2*T(N/2)+O(1)
$$

##### 时间复杂度

当$log_ba > d$时，时间复杂度为$O(N^{log_ba})$

当$log_ba < d$时，时间复杂度为$O(N^d)$

当$log_ba = d$时，时间复杂度为$O(N^d*logN)$

#### 比较器Comparator

返回负数时，第一个参数排在前面

返回正数时，第二个参数排在前面

返回0时，无所谓谁排在前面

#### 排序算法的复杂度总结

|               | 时间复杂度       | 空间复杂度   | 稳定性 |
|:-------------:|:-----------:|:-------:|:---:|
| 选择排序          | $O(N^2)$    | O(1)    | ×   |
| 冒泡排序          | $O(N^2)$    | O(1)    | √   |
| 插入排序          | $O(N^2)$    | O(1)    | √   |
| 快速排序3.0（优先使用） | $O(N*logN)$ | O(logN) | ×   |
| 归并排序          | $O(N*logN)$ | O(N)    | √   |
| 堆排序           | $O(N*logN)$ | O(1)    | ×   |

#### 综合排序

在样本量很大的时候，可以利用快速排序的调度，体现快速排序的时间复杂度优势，但当递归过程中，待排序的数组长度小等于某一个值（60）可以在局部利用插入排序常数小的优势对局部数组进行排序。同样可以使用在大样本归并排序中。

#### Array.Sort

系统的Array自带的sort方法在发现数组的元素类型为基本类型时，会使用快速排序，非基本类型时，会使用归并排序，目的是为了数组的稳定性。

### 树

#### 怎么判断一棵树是不是搜索二叉树

搜索二叉树指的是一棵树的每一个子树都满足左边比根小，右边比根大。

通过中序遍历的过程中，判断输出节点是否呈升序

#### 怎么判断一棵树是不是完全二叉树

通过广度遍历优先的方式判断

1）任一节点如果有右节点没有左节点，false

2）满足1的情况下，如果出现左右子节点不双全的情况下，以后出现的所有节点都需要是叶子节点，否则false

#### 怎么判断一棵树是不是满二叉树

好理解但是麻烦的方法是计算树的节点个数N以及树的深度C，当N和C满足$N=2^C-1$时该树就是满二叉树

#### 怎么判断一棵树是不是平衡二叉树

每一个节点的左右子树均满足 1）该子树是平衡二叉树；2）左右子树的高度差不超过1；

### 二叉树题目的套路

在我可以向左右子树要信息的情况下，去思考 1）我需要向左子树要什么样的信息，我需要向右子树去要什么样的信息，如果需要的信息不同，需要将信息整合才能成一个整体，才能运用于递归之中。2）我要如何去返回父节点所需要的信息。

代码参考day06/JudgeTree

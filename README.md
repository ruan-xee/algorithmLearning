# algorithmLearning

关于算法的学习、笔记、代码练习

#### 对数器

##### 思路：

 有一个你待测的方法a，以及一个不计时间成本和空间成本但稳定的方法b

对同一数组（不是同一个地址的数组，是指数组长度、内容值相同的）分别使用两个方法运行

得到的两个结果进行一一比对，可以验证待测方法的运行结果是否正确

##### 优点：

不用依赖平台OG来验证自己写的方法是否正确

比对次数可以自己定义

每次比对的数组长度、数组内容可以自己定义范围

待发现错误时，可以通过缩小数组长度、数值范围等控制变量来进行debug修正

#### master公式的使用

master公式是对递归方法的算法复杂度进行分析

##### 定义

其公式表示为

$$
T(N)=a*T(N/b)+O(N^d)
$$

其中，当且仅当递归时的子部分划分为完全相等的部分时才可以该套用公式

a表示递归调用次数，b表示子部分占比取反，O(N^d)表示除递归操作外，其它操作占用时间复杂度

##### 例如

将一个数组取左右两半进行递归，找出数组最大值

那么在这个例子中，a表示需要将左右两个子部分都进行递归，所以次数为2

每部分占比为1/2，取反为2，所以b为2

除递归方法外，找出数组最大值需要进行一个比较操作，时间复杂度为O(1)

所以套入公式可得

$$
T(N)=2*T(N/2)+O(1)
$$

##### 时间复杂度

当$log_ba > d$时，时间复杂度为$O(N^{log_ba})$

当$log_ba < d$时，时间复杂度为$O(N^d)$

当$log_ba = d$时，时间复杂度为$O(N^d*logN)$



#### 比较器Comparator

返回负数时，第一个参数排在前面

返回正数时，第二个参数排在前面

返回0时，无所谓谁排在前面

#### 排序算法的复杂度总结

|                         | 时间复杂度  | 空间复杂度 | 稳定性 |
| :---------------------: | :---------: | :--------: | :----: |
|        选择排序         |  $O(N^2)$   |    O(1)    |   ×    |
|        冒泡排序         |  $O(N^2)$   |    O(1)    |   √    |
|        插入排序         |  $O(N^2)$   |    O(1)    |   √    |
| 快速排序3.0（优先使用） | $O(N*logN)$ |  O(logN)   |   ×    |
|        归并排序         | $O(N*logN)$ |    O(N)    |   √    |
|         堆排序          | $O(N*logN)$ |    O(1)    |   ×    |

#### 综合排序

在样本量很大的时候，可以利用快速排序的调度，体现快速排序的时间复杂度优势，但当递归过程中，待排序的数组长度小等于某一个值（60）可以在局部利用插入排序常数小的优势对局部数组进行排序。同样可以使用在大样本归并排序中。

#### Array.Sort

系统的Array自带的sort方法在发现数组的元素类型为基本类型时，会使用快速排序，非基本类型时，会使用归并排序，目的是为了数组的稳定性。
